<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D 跑酷遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 遊戲專屬的自定義樣式 */
        body {
            background-color: #1a1a2e; /* 深藍色背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
            flex-direction: column;
            padding: 20px;
        }

        #game-container {
            background-color: #0f0f1a;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            display: block;
            border: 4px solid #4a4a6e;
            border-radius: 8px;
            background-color: #1f2041; /* Canvas 內部背景 */
            touch-action: none; /* 防止移動端滾動 */
        }

        .info-panel {
            width: 100%;
            max-width: 600px;
            margin-bottom: 15px;
            color: #ffffff;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls {
            margin-top: 15px;
            text-align: center;
            color: #d1d1e0;
            font-size: 0.9rem;
            max-width: 600px;
        }

        .key {
            display: inline-block;
            padding: 3px 8px;
            margin: 0 2px;
            background-color: #4a4a6e;
            border-radius: 4px;
            border-bottom: 3px solid #33334c;
            color: #ffffff;
            font-weight: bold;
            font-family: monospace;
        }

        .mobile-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .mobile-button {
            padding: 15px 30px;
            background-color: #5555ff;
            color: white;
            border-radius: 50%;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 5px #333399;
            transition: background-color 0.1s;
            user-select: none;
        }

        .mobile-button:active {
            box-shadow: 0 2px #333399;
            transform: translateY(3px);
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="info-panel">
        <div id="score-display">分數: 0</div>
        <div id="game-message">點擊空白鍵或畫面開始！</div>
    </div>
    <canvas id="parkourCanvas"></canvas>
    <div class="controls">
        <p class="mb-2 font-semibold text-white">
            **操作說明 (Instruction):**
        </p>
        <p>
            使用鍵盤：<span class="key">空白鍵</span> 或 <span class="key">↑</span> **跳躍**。
        </p>
        <p class="mt-1">
            遊戲結束後按 <span class="key">R</span> **重新開始**。
        </p>
        <div id="mobile-controls-ui" class="mobile-controls md:hidden">
            <div id="jump-button" class="mobile-button">跳躍</div>
        </div>
    </div>
</div>

<script>
    // 全局變數和初始化
    const canvas = document.getElementById('parkourCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score-display');
    const gameMessage = document.getElementById('game-message');
    const jumpButton = document.getElementById('jump-button');

    // 遊戲常數
    const PLAYER_WIDTH = 30;
    const PLAYER_HEIGHT = 30;
    const GRAVITY = 0.6;
    const JUMP_STRENGTH = -15; // **已調整為 -15，跳躍強度適中**
    const HORIZONTAL_SPEED = 6;
    const MAX_PLATFORM_GAP = 200;
    const MIN_PLATFORM_GAP = 100;
    const MAX_PLATFORM_WIDTH = 150;
    const MIN_PLATFORM_WIDTH = 80;

    // 遊戲狀態
    let isGameOver = false;
    let isGameRunning = false;
    let score = 0;
    let frame = 0;
    let platforms = [];
    let keys = {};
    let lastPlatformX = 0;

    // 設置 Canvas 尺寸並使其響應式
    function resizeCanvas() {
        // 設定固定比例或根據容器大小調整
        canvas.width = 600;
        canvas.height = 350;
        // 在這裡可以加入更複雜的響應式邏輯，但為了單一文件範例，先使用固定尺寸
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // --- 玩家類別 ---
    class Player {
        constructor() {
            this.x = 50;
            this.y = canvas.height - PLAYER_HEIGHT - 50; // 初始位置略高於第一平台
            this.width = PLAYER_WIDTH;
            this.height = PLAYER_HEIGHT;
            this.vy = 0; // 垂直速度
            this.vx = 0; // 水平速度
            this.onGround = false;
            this.color = '#ff6b6b'; // 紅色
        }

        update() {
            // 應用重力
            this.vy += GRAVITY;
            this.y += this.vy;

            // 應用水平速度 (玩家只在遊戲開始後才能移動)
            if (isGameRunning) {
                // 模擬連續跑步 (強制向右)
                this.vx = HORIZONTAL_SPEED;
            } else {
                this.vx = 0;
            }

            this.x += this.vx;

            // 保持玩家在左側邊界內
            this.x = Math.max(0, this.x);

            // 檢查是否掉出畫面底部 (遊戲結束)
            if (this.y + this.height > canvas.height + 50) {
                if (isGameRunning) {
                    gameOver();
                }
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        jump() {
            if (this.onGround) {
                this.vy = JUMP_STRENGTH;
                this.onGround = false;
            }
        }
    }

    // --- 平台類別 ---
    class Platform {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = '#4ecdc4'; // 青綠色
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        update() {
            // 平台向左移動，速度與玩家模擬的跑步速度相同
            if (isGameRunning) {
                this.x -= HORIZONTAL_SPEED;
            }
        }
    }

    // 初始化玩家
    const player = new Player();

    // --- 碰撞檢測 ---
    function checkCollision(player, platform) {
        // AABB 碰撞檢測
        return (
            player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y < platform.y + platform.height &&
            player.y + player.height > platform.y
        );
    }

    // --- 遊戲邏輯 ---

    function generatePlatforms() {
        const MIN_HEIGHT = canvas.height * 0.3;
        const MAX_HEIGHT = canvas.height * 0.8;

        // 生成下一塊平台
        if (lastPlatformX < canvas.width + 100) {
            let platformWidth = Math.floor(Math.random() * (MAX_PLATFORM_WIDTH - MIN_PLATFORM_WIDTH + 1)) + MIN_PLATFORM_WIDTH;
            let gap = Math.floor(Math.random() * (MAX_PLATFORM_GAP - MIN_PLATFORM_GAP + 1)) + MIN_PLATFORM_GAP;
            let platformX = lastPlatformX + gap;

            // 確保平台不會生成在太高或太低的地方
            let platformY = Math.floor(Math.random() * (MAX_HEIGHT - MIN_HEIGHT + 1)) + MIN_HEIGHT;

            // 讓玩家能夠順利開始，第一塊平台固定
            if (platforms.length === 0) {
                platformX = 0;
                platformWidth = canvas.width;
                platformY = canvas.height - 30; // 初始地板
            }

            platforms.push(new Platform(platformX, platformY, platformWidth, 30));
            lastPlatformX = platformX + platformWidth;
        }

        // 移除移出畫面的平台
        platforms = platforms.filter(p => p.x + p.width > -100);
    }

    function handleCollisions() {
        player.onGround = false;

        platforms.forEach(platform => {
            if (checkCollision(player, platform)) {
                // 檢查是否是從上方撞擊 (落地)
                if (player.vy > 0 && player.y + player.height - player.vy <= platform.y) {
                    // 修正玩家位置到平台頂部
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                } else if (player.vy < 0 && player.y + player.height - player.vy >= platform.y + platform.height) {
                    // 撞到平台底部 (阻止上升)
                    player.vy = 0;
                    player.y = platform.y + platform.height;
                }
                // 這裡我們只專注於垂直碰撞，水平碰撞通常代表跑酷失敗或需要更複雜的遊戲設計
            }
        });
    }

    function updateGame() {
        if (isGameOver || !isGameRunning) return;

        frame++;
        if (frame % 10 === 0) {
            score++;
            scoreDisplay.textContent = `分數: ${score}`;
        }

        // 讓玩家不斷向右移動
        player.update();

        // 更新平台位置 (模擬世界向左移動)
        platforms.forEach(p => p.update());

        // 處理碰撞
        handleCollisions();

        // 根據玩家位置生成新的平台
        generatePlatforms();
    }

    function drawGame() {
        // 清除畫布
        ctx.fillStyle = '#1f2041';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 繪製平台
        platforms.forEach(p => p.draw());

        // 繪製玩家
        player.draw();

        // 顯示遊戲狀態
        if (!isGameRunning && !isGameOver) {
            ctx.fillStyle = 'white';
            ctx.font = '30px Inter';
            ctx.textAlign = 'center';
            // 提示玩家開始遊戲的方式
            ctx.fillText('按 空白鍵 或 點擊 畫面開始跳躍', canvas.width / 2, canvas.height / 2);
        } else if (isGameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '40px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('遊戲結束', canvas.width / 2, canvas.height / 2 - 30);
            ctx.fillStyle = 'white';
            ctx.font = '20px Inter';
            ctx.fillText(`最終分數: ${score}`, canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText('按 R 重新開始', canvas.width / 2, canvas.height / 2 + 50);
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        updateGame();
        drawGame();
    }

    function startGame() {
        if (isGameRunning) return;
        isGameOver = false;
        isGameRunning = true;
        score = 0;
        frame = 0;
        platforms = [];
        lastPlatformX = 0;

        // 重新初始化玩家
        player.x = 50;
        player.y = canvas.height - PLAYER_HEIGHT - 50;
        player.vy = 0;

        // 初始化第一個平台 (地面)
        generatePlatforms();

        gameMessage.textContent = '跑酷進行中...';
    }

    function gameOver() {
        isGameRunning = false;
        isGameOver = true;
        gameMessage.textContent = '遊戲結束！按 R 重新開始';
    }

    // --- 輸入事件處理 ---
    document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        if (e.key === ' ' || e.key === 'ArrowUp') {
            e.preventDefault(); // 防止空白鍵滾動頁面
            if (!isGameRunning && !isGameOver) {
                startGame();
            } else if (isGameRunning) {
                player.jump();
            }
        }

        if (isGameOver && (e.key === 'r' || e.key === 'R')) {
            startGame();
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });

    // 移動端跳躍按鈕
    jumpButton.addEventListener('click', () => {
        if (!isGameRunning && !isGameOver) {
            startGame();
        } else if (isGameRunning) {
            player.jump();
        }
    });

    // 點擊 Canvas 也可以跳躍/開始
    canvas.addEventListener('click', () => {
        if (!isGameRunning && !isGameOver) {
            startGame();
        } else if (isGameRunning) {
            player.jump();
        }
    });

    // 初始化時畫出畫面
    window.onload = function () {
        // 初始化第一個平台 (地面)
        generatePlatforms();
        animate();
    };

</script>
</body>
</html>
